关键词：结构化（顺序、分支、循环）	变量	数组	结构	函数	指针	文件	位运算



## 1. 计算机、程序设计与 C 语言

> 程序 = 算法 + 数据结构 --Nikiklaus Wirth



### 1. 1 程序

#### 程序

指一组计算机能识别和执行的指令，一个特定的指令序列完成一定的功能。

计算机的一切操作都是由程序控制的，计算机本质上是程序的机器，程序和指令是计算机中最基本的概念。

程序包括：

- 数据结构：是加工对象，对数据的描述，在程序中要指定用哪些数据、数据的类型及数据的组织形式。
- 算法：对操作的描述，即要求计算机进行操作的步骤。（有穷、确定、零或多个输入、1 或多个输出、有效）
- 语言是工具，编程需要采用合适的方法。



####  程序设计

从确定任务到得到结果、写出文档的全过程。

- 问题分析（建模）
- 设计算法（流程图）
- 编写程序
- 对源文件进行编辑、编译和连接（得到可执行程序）
- 运行程序，分析结果（调试、测试）
- 编写程序文档（用户文档）



####  结构化程序设计方法

把一个复杂问题的求解过程分阶段进行，每个阶段处理的问题都控制在人们容易理解和处理的范围内。

强调设计风格和程序结构的规范化，提倡清晰的结构。顺序、选择、循环是 3 种基本结构。

保证得到结构化程序的方法：

- 自顶向下，逐步细化：用工程的方法设计程序，便于验证算法的正确性。
- 模块设计：分治，即把一个大任务划分成若干个易于解决的子任务。要点是应保证模块独立性，即使用一个模块完成一项功能，满足「高内聚低耦合」的原则。（C 语言通过函数实现程序的子模块）



#### 算法表示

自然语言、传统流程图、结构化流程图、盒图、伪代码、计算机语言（实现）。



### 1.2 计算机语言

人和计算机交流信息需要语言，计算机语言是人类创造出来的、计算机和人类都能识别的语言：

- 机器语言：由 0 和 1 组成的指令，基于二进制的计算机唯一能识别和接收的语言。（计算机低级语言：面向机器）
- 汇编语言：由英文字母和数字表示一个指令，一条符号语言的指令对应转换成一条机器指令。（计算机低级语言：面向机器）
- 高级语言：不依赖与具体机器，高级语言的一条语句往往对应多条机器指令。

三个阶段：

- 非结构化语言：FORTRAN 等。

- 结构化语言：如 C 语言，基于过程，编程时需要指定每一个过程的细节。

- 面向对象：对象 = 数据 + 对数据进行的操作，如 C++、Java等。

  

### 1.3 C 语言

C 是一个很小的内核语言，只包括很少的与硬件有关的部分。

C 语言不直接提供输入输出、文件操作和动态内存管理的语句，这些操作都由编译系统所提供的库函数实现。

不提供输入输出语句，就可以避免在编译阶段处理与硬件有关的问题，可以使编译系统简化，且通用性强，可移植性好。

C的类型系统和错误检查仅在编译时（ compile-time）存在。 编译后的代码在精简的运行时（run-time）模型，该模型没有针对非法类型强制转换，不良数组索引或错误的指针的安全检查。C语言也没有提供垃圾收集器来管理内存，而是需要程序员手动管理堆内存。

```c
// 单行注释

/*
多行
注释
*/
```

#### C 语言的主要特点

- 语言简洁、紧凑，使用方便、灵活：37 个关键字、9 种控制语句
- 运算符丰富：34 种运算符
- 数据类型丰富：指针类型能用来实现复杂数据结构（链表、树、栈等）
- 结构化的控制语句：完全模块化和结构化，函数时程序的模块单位
- 语法限制不太严格，程序设计自由度大
- C语言运行直接访问物理地址，能进行位（bit）操作
- 可移植性好
- 生成目标代码质量高，程序执行效率高



#### C 语言程序结构

- 一个程序由一个或多个源程序文件组成：编译单位是单个源程序文件，一个源程序文件可以包括预处理指令、全局声明、函数定义。

- 函数是 C 程序的主要组成部分：C语言程序由一个或多个函数组成，必须且只能有一个 `main()`函数。

- 一个函数包括两部分：函数首部、函数体（声明部分和执行部分）。

- 程序总是从  `main()`函数开始执行的。

- 程序中要求计算机完成的操作是由函数中的 C 语句完成的。

- 在每个数据声明和语句的最后必须有一个分号。

- C 语言本身不提供输入输出语句，C语言对输入输出实行「函数化」。

- 程序应当包含必要的注释。

  

#### 运行 C 程序的步骤

<img src="img/C程序执行过程.png" alt="C_01" style="zoom: 25%;" />



## 2. C 语法简介

### 2.1 常量、变量和数据类型



> 常量、变量是计算机高级语言中数据的两种表现形式。在定义变量时需要指定数据类型，常量也区分类型。
>
> 数据类型：对数据分配存储单元的安排，包括存储单元长度（占多少字节）、数据存储形式。不同类型分配不同的长度和存储形式。存储单元是由有限的字节构成的，存放数据范围有限，计算机用工程的方法实现的是近似计算而不是理论计算，所以计算机运算时要指定数据类型。



常量：程序运行过程中值不能被改变的量。

| 常量       | 含义或形式                                                   | 举例                |
| ---------- | ------------------------------------------------------------ | ------------------- |
| 整型常量   | 整数                                                         | 0，99，-249         |
| 实型常量   | 十进制小数、指数形式（e或 E前必须有数字，且e或 E后必须为整数） | 2.345、12.3e2       |
| 字符常量   | 普通字符（单撇号，‘a’）、转义字符（\n）                      | 转义字符（表 3.1）  |
| 字符串常量 | 双撇号中的全部字符                                           | `“Hello, World!”`   |
| 符号常量   | 用一个符号代表一个常量(见名知义)，一改全改。预编译时做字符替换，临时符号不占内存。 | `#define PI 3.1416` |

变量：一个有名字的、具有特定属性的存储单元，用来存放数据（变量值，可变）。

变量名：用一个名字表示的存储地址，在对程序编译连接时由编译系统给没一个变量名分配对应的内存地址。

变量值：存储在变量名所表示的存储单元中的数据。

从变量中取值：通过变量名找到相应的内存地址，从该存储单元中读取数据。

常变量（C99）：具有变量的属性（有类型、占存储单元），但不允许改变其值。

```c
int a = 3;
```



标识符：用来对变量、符号常量、函数、数组、类型等进行命名的有效字符序列。标识符命名规则：

- 由字母、数字、下划线组成
- 第一个字符不能时数字
- 区分大小写（变量名一般习惯小写）。



数据类型：一般情况，long 32位，short 16 位，int 16位或 32 位（由编译系统决定）。

```c
sizeof(short) ≤ sizeof(int) ≤ sizeof(long) ≤ sizeof(long long)
```

<img src="img/C_datatype.png" alt="image-20200910195845274" style="zoom:75%;" />

不同整型实现每种类型的位数（“宽度”）不同，较宽的类型可以存储的值范围更大。整型主要包括：char、short、int(默认的整型)、long。可以在整型前加上 unsigned 关键字，标识无符号（非负）整型。除非必须，尽量不使用 unsigned。



### 2.2 运算符和表达式

优先级和结合性：

- 表达式求值时，先按运算符的「优先级」顺序执行。

- 若在一个运算对象（常量、变量、函数等）的两侧运算符优先级相同，按规定的「结合方向」处理。

- 算术运算符是从左至右，赋值运算符是从右至于左。

![运算符的优先级和结合方向](img/运算符的优先级和结合方向.png)



自动类型转换：系统自动进行。整型、实型、字符型数据可以混合运算，规律：

- 「加减乘除」运算的两个数中有一个数为 float 或 double型，则结果为 double 型。

- 字符（char）型数据与整数数据运算，即是把字符的 ASCII 码 与整型数据运算。

  

强制类型转换：将一个表达式转换成所需类型。

- 在强制类型转换时，得到一个所需类型的中间值，原来变量的类型没变。如果接下来有赋值，该临时值赋值后就不存在了。
- 在函数调用时，有时为了时实参与形参类型一致，可以用强制类型转换运算符得到一个所需类型的参数。

```C
(类型名)(表达式)
(double)a
(int)(x+y)
(float)(5%3)
```



### 2.3  C 语句

语句：向计算机系统发出操作指令，要求执行相应的操作。分号（;）是语句结束符，是属于语句的一部分。

函数的执行部分就是由语句组成的。一条 C 语句编译后会产生若干条机器指令。

<img src="img/C_Statements.png" alt="image-20200910204301276" style="zoom:50%;" />

注：赋值语句属于表达式语句，进行赋值时需要首先确定赋值号两侧的类型是否相同，是否允许赋值。赋值语句这类代码必
须出现在函数中。



赋值语句：使用赋值运算符 （=）。

复合的赋值运算符 ：凡二元运算符均可以与赋值运算符组成复合的赋值运算符。+=，其他类似。

赋值表达式：由赋值运算符将一个变量和一个表达式连接起来的式子，具有「计算 + 赋值」双重功能。

赋值表达式的求解过程：先求赋值运算符右边的”表达式“的值，然后赋给赋值运算符左边的变量。

```c
// 赋值表达式加个分号，是赋值语句。
变量 = 表达式;
变量 += 表达式;

// 两条等价语句
a=(b=5);
a=b=5;

print("%d", a=b=5);
```

- 可修改的左值：「左值」是指赋值操作符左边的操作数，所有的左值都必须可以修改，因为它们会被赋值。左值应为存储空间并可以被赋值，比如变量。
- 右值：常量、变量、表达式。
- 赋值表达式中的「表达式」可以是一个赋值表达式，把赋值表达式作为表达式的一种，使赋值操作不仅可以出现在赋值语句中，而且可以以表达式的形式出现在其他语句（循环、输出语句）中。
- 赋值过程中的类型转换：整型数据之间的赋值，按存储单元中的存储形式直接转换；实型数据之间、整型与实型数据之间，是先转换类型后赋值。注意：要「避免」把占字节多的整型数据向占字节少的整型变量赋值，原因「低位保留，高位截丢」。
- C 语言将赋值语句与赋值表达式做区分，增加了表达式种类。
- 一个表达式中可以包含一个或多个赋值表达式，但不能包含赋值语句。
- 变量赋初值：在程序运行时执行本函数时赋予初值的。



### 2.4 数据的输入输出

scanf 函数和printf函数：

````c
// 输入：
scanf(格式控制，地址表列);			// 地址表列：变量地址
scanf("a=%d,b=%d",&a,&b);		  // 【特别注意】输入数据时，在对应的位置上输入同样的字符（如此处的逗号）
scanf("%c%c%c",&ch1,&ch2,&ch3);	  // %c：此时空格和转义字符都会作为有效字符输入

// 输出
printf(格式控制，输出表列);
printf("a = %格式字符",a);
if(i%8==0) printf("\n");		//	控制每输出 8 个字符换行
````

- 输入数值时，两个数值之间需要插入分隔符（如空格）
- 连续输入字符时，在两个字符之间不要插入分隔符（包括空格），【特别注意】的这种情况除外
- 输入数值数据时，如输入空格】回车、Tab 键或遇非法字符（不属于数值的字符），认为该数据结束。



字符输入输出函数：

````c
putchar(c);		 			//	输出字符变量 c 的值，c可以是字符常量/变量、整型常量/变量(ASCII 范围内)。
putchar('\''); 				//	也可以输出转义字符:如输出单引号

ch = getchar();				//	只能接收一个字符，可以赋给字符型或整型变量
putchar(getchar());			//	将接收的字符输出，也可以作为表达式的一部分
printf("%c",getchar());
````

- 使用键盘输入信息时，字符先暂存在键盘的缓冲区，只有按了 `Enter` 键之后才把这些字符一起输入计算机，然后按先后顺序分别赋给相应的变量。
- 执行 `getchar` 函数可以从输入设备获得可显示字符，也可以获得控制字符等无法显示的字符。



### 2.5 控制流

#### 分支（条件判定）

`if-else` 语句：用于条件判定，else 部分是可选的。在嵌套的 if 语句中，为了避免歧义，将每个 else 与最近的前一个没有 else 配对的 if 进行匹配。（建议）使用花括号强制实现正确的匹配关系。

`else-if` 语句：常用于编写多路判定。各表达式将被依次求值，一旦某个表达式结果为真，则执行与之相关的语句，并终止整个语句序列的执行。同样，其中各语句既可以是单条语句，也可以是用花括号括住的复合语句。

```c
if (表达式) 
	语句
else if (表达式) 
	语句
else if (表达式) 
	语句
else 
	语句
```

举例：折半查找，在每一步判断 x 小于、大于还是等于中间元素 v[mid]。

```c
// 折半查找: 在 v[0] <= v[1] <= ... <= v[n-1]查找 x 
int binarySearch(int x, int v[], int n) 
{ 
    int low, high, mid; 
    low = 0; 
    high = n - 1; 
    while (low <= high) { 
            mid = (low+high)/2; 
            if (x < v[mid]) 
                    high = mid + 1; 
            else if (x > v[mid]) 
                    low = mid + 1; 
            else //匹配成功 
                    return mid; 
    } 
    return -1; //查找失败
}
```



`switch` 语句：多路判定语句，测试表达式是否与一些常量整数值中的某一个值匹配，并执行相应的分支动作。

```c
switch (表达式) 
{ 
	case 常量表达式: 语句序列
	case 常量表达式: 语句序列
	default: 语句序列
}
```

- 每一个分支都由一个或多个整数值常量或常量表达式标记，各分支表达式必须互不相同。

- default 分支是可选的。如果没有哪一分支能匹配表达式，则执行标记为 default 的分支。

- 使用 break 语句与 return 语句是跳出 switch 语句最常用的方法。

- 正常情况下为了防止直接进入下一个分支执行，每个分支后必须以一个 break 语句结束。

- 应尽量减少从一个分支直接进入下一个分支执行这种用法，在不得不使用的情况下应该加上适当的程序注释。

- 作为一种良好的程序设计风格，在 switch 语句最后一个分支（即 default 分支）的后面也加上一个 break 语句。



#### 循环

`while` 循环与 `for` 循环：在循环体执行前对终止条件进行测试。

```c
while (表达式) 
		语句
  
表达式 1; 
while (表达式 2) { 
		语句
		表达式 3; 
}

//未包含 continue 语句时，和上面👆的while 语句等价
for (表达式 1; 表达式 2; 表达式 3) 
		语句
```

- for 循环语句的 3 个组成部分都是表达式：（常见情况）表达式 1与表达式 3 是赋值表达式或函数调用，表达式 2 是关系表达式。这 3 个组成部分中的任何部分都可以省略，但分号必须保留。
- 在设计程序时到底选用 while 循环语句还是 for 循环语句，主要取决于程序设计人员的个人偏好。
- 没有初始化或重新初始化的操作，使用 whi1e 循环语句更自然。
- for 语句具有很强的通用性。语句中需要执行简单的初始化和变量递增，使用 for 语句更合适，它将循环控制语句集中放在循环的开头，结构更紧凑、更清晰。把循环控制部分集中在一起，对于多重嵌套循环，优势更明显。

```c
for (i = 0; i < n; i++) 		//C 语言处理数组前 n 个元素的习惯用法
...
```

Shell 排序的基本思想：先比较距离远的元素，而不是像简单交换排序算法那样先比较相邻的元素。这样可以快速减少大量的无序情况，从而减轻后续的工作。被比较的元素之间的距离逐步减少，直到减少为 1，这时排序变成了相邻元素的互换。

该函数中包含一个三重嵌套的 for 循环语句:

- 最外层的 for 语句控制两个被比较元素之间的距离，从 n/2 开始，逐步进行对折，直到距离为 0。
- 中间层的 for 循环语句用于在元素间移 动位置。
- 最内层的 for 语句用于比较各对相距 gap 个位置的元素，当这两个元素逆序时把它 们互换过来。由于 gap 的值最终要递减到 1，因此所有元素最终都会位于正确的排序位置上。

```c
// shellsort: sort v[0]...v[n-1] into increasing order
void shellsort(int v[], int n) 
{ 
	int gap, i, j, temp; 
  
	for (gap = n/2; gap > 0; gap /= 2) 
			for (i = gap; i < n; i++) 
				for (j=i-gap; j>=0 && v[j]>v[j+gap]; j-=gap) { 
						temp = v[j]; 
							v[j] = v[j+gap]; 
							v[j+gap] = temp; 
				} 
}
```

逗号运算符“`,`”也是 C 语言优先级最低的运算符，在 for 语句中经常会用到它。被逗号分隔的一对表达式将按照从左到右的顺序进行求值，表达式右边的操作数的类型和值即为其结果的类型和值。这样，在 for 循环语句中，可以将多个表达式放在各个语句成分中，比 如同时处理两个循环控制变量。

某些情况下的逗号并不是逗号运算符，比如分隔函数参数的逗号，分隔声明中变量的逗号等，这些逗号并不保证各表达式按从左至右的顺序求值。

应该慎用逗号运算符。逗号运算符最适用于关系紧密的结构中。

```c
for (i = 0, j = strlen(s)-1; i < j; i++, j--) 
		c = s[i], s[i] = s[j], s[j] = c;
```



`do-while` 循环：在循环体执行后测试终止条件， 这样循环体至少被执行一次。先执行循环体中的语句部分，然后再求表达式的值。如果表达式的值为真， 则再次执行语句，依此类推。当表达式的值变为假，则循环终止。

```c
do 
	语句
while (表达式);
```



#### break 语句

可用于从for、while与do-while等循环中提前退出，就如同从switch语句中提前退出一样。break 语句能使程序从 switch 语句或最内层循环中立即跳出。

#### continue 语句

与 break 语句是相关联的，但它没有 break 语句常用。continue 语 句用于使 for、while 或 do-while 语句开始下一次循环的执行。在 while 与 do-while 语句中，continue 语句的执行意味着立即执行测试部分；在 for 循环中，则意味着使控制转移到递增循环变量部分。continue 语句只用于循环语句，不用于 switch 语句。某个循环包含的 switch 语句中的 continue 语句，将导致进入下一次循环。

当循环的后面部分比较复杂时，常常会用到 continue 语句。这样做可以避免程序的过度嵌套。



#### goto 语句与标号

最常见的用法：终止程序在某些深度嵌套的结构中的处理过程，例如一次跳出两层或多层循环。这种情况下使用 break 语句是不能达到目的的，它只能从最内层循环退出到上一级的循环。所有使用了 goto 语句的程序代码都能改写成不带 goto 语句的程序，但可能会增加一些额外的重复测试或变量。大多数情况下，使用 goto 语句的程序段比不使用 goto 语句的程序段要难以理解和维护， 尽可能少用。

标号：命名同变量命名的形式相同，标号的后面要紧跟一个冒号。标号可以位于对应的 goto 语句所在函数的任何语句的前面。标号的作用域是整个函数。

```c
// 判定两个数组 a 与 b 中是否具有相同元素
for (i = 0; i < n; i++) 
		for (j = 0; j < m; j++) 
				if (a[i] == b[j]) 
						goto found; 
		// 无任何共同元素
		... 
found: 
		// 找到一个共同元素: a[i] == b[j] 
		...
```



## 3. 数组



数组是一组类型相同的变量的集合，数组的元素在内存中是连续存放的。

一维数组这种数据类型可以表示数学中的向量、有限序列的数据、需要批处理的成组的数据对象（对一组类型相同的数据进行排序、搜索）等。

二维数组可以分解为多个一维数组，可以用来表示矩阵等。

注意：数组下标从 0 开始，使用数组时要保证下标不越界。计算 `a[i][j]`在数组中相对位置的计算公式：`i*m+j`。



### 一维数组

````c
类型名 数组名[数组长度];			//一维数组定义

int a[5]={18,30,66,99，101};	  //只有在定义数组的同时才能进行整体初始化（此时长度 5 可以省略）

int t=a[2];					  //引用一维数组的元素：第3个元素(只能访问数组的单个元素)
````

- 不允许对数组大小做动态定义。

- 数组名：代表数组的基地址（第一个元素的地址），是一个常量，不能出现在赋值号左边。

- 初始化

  - 完全初始化：在定义数组的同时才能进行整体初始化。
  - 不完全初始化：部分初始化或未初始化时未被初始化的元素值会被自动赋值（数值型 0、字符型’\0’、指针型 NULL）

  

【举例】Fibonacci 数列、冒泡排序。

````c
/*冒泡排序：版本一*/
#include <stdio.h>

int main()
{
    int a[6];
    int i,j,temp;
    
    printf("Input 6 numbers：\n");    //输入数据
    for(i=0;i<6;i++)
        scanf("%d",&a[i]);
    printf("\n");
                                    //冒泡排序
    for(j=0;j<5;j++)
        for(i=0;i<5-j;i++)
            if(a[i]>a[i+1])
            {
                temp=a[i];a[i]=a[i+1];a[i+1]=temp;
            }
                                    //输出数据
    printf("The sorted numbers:\n");
    for(i=0;i<6;i++)
        printf("%d ",a[i]);
    printf("\n");
    return 0;
}
````

通过函数访问一维数组：经过编译后，对应的实参均为`（数组名，元素个数）`。

````c
void someFunc(int someArray[9],int sizeOfArray);	//形参：已定义大小的数组

void someFunc(int someArray[],int sizeOfArray);		//形参：未定义大小的数组

void someFunc(int *someArray,int sizeOfArray);		//形参：一个指针
````

###  二维数组

二维数组是特殊的一维数组，它的每一个元素又是一个一维数组。按行存放，二维是指逻辑上的，实际在内存中仍是线性存放的。

`a+1`代表序号为 1 的行的起始地址：`a+1` 指向 `a[1]`，`a+1`的值是 `a[1]`的起始地址。

三维数组定义类似（页、行、列）。

````c
/*矩阵转置：行列互换*/
#include <stdio.h>

int main()
{
    int a[2][3]={{},{}};
    int b[3][2];
    int i,j;
    
    printf("Input 6 numbers in order(by rows):\n");
    for(i=0;i<2;i++)					// 双层 for 循环嵌套
        for(j=0;j<3;j++)
        {
            scanf("%d",&a[i][j]);
            if(j%3==0) printf("\n");
            printf("%3d ", a[i][j]);
            b[j][i]=a[i][j];			//赋值：实现行列互换
        }
    printf("\n\n");
    
    printf("After Transpose:\n");
    for(j=0;j<3;j++)
        for(i=0;i<2;i++)
        {
            if(i%2==0) printf("\n");
            printf("%3d ", b[j][i]);
        }
    printf("\n");
    return 0;
}
````

````c
/*
矩阵乘法的实现: C=AB，非方阵，不失一般化
核心代码：三层 for 循环嵌套 + 复合赋值语句
关键：理解矩阵乘法AB的行列法则（AB的每一列都是 A 的各列的线性组合，以 B 的对应列的元素为权。
*/

#include <stdio.h>

int main()
{
    int a[2][3]={{1,0,3},{2,-1,0}};
    int b[3][2]={{1,-1},{2,3},{4,0}};
    int i,j,k, c[2][2]={0};	//初始化很重要，未初始化的计算结果最右上角结果总比正确值大 1，应该是某个存储位置原本有值 1
    
    for(i=0;i<2;i++)
        for(j=0;j<3;j++)
            for(k=0;k<2;k++)
            {
                c[i][k]+=a[i][j]*b[j][k];   //矩阵乘法AB的行列法则
            }
    
    printf("Mutrix Multiple Results:\n");
    for(i=0;i<2;i++)
        for(j=0;j<2;j++)
        {
           if(j%2==0) printf("\n");
           printf("%3d ", c[i][j]);
        }
    printf("\n");
    return 0;
}
//结果：c[2][2]={{13,-1},{0,-5}}
````



### 字符数组

字符数组：用来存放字符数据的数组，一个元素内存放一个字符。

C 没有定义字符串类型，也没有字符串变量，字符串是存放在「字符型数组」里的。

字符型数据以「字符的 ASCII 码」存放在存储单元，属于整型，一般占 1B。

````c
char char_array[23];			  //定义（使用前务必初始化,可以一个字符一个字符的初始化）
char_array[23]={"Just Try It!"};  //也可以使用字符串常量初始化（自动加'\0'作为结束符，仅作为辨识字符串是否结束的标志）

/*一个示例*/
#include <stdio.h>

int main()
{
    char c,salution[]="Hello,guys!";            //定义并使用字符串常量初始化
    printf("%s\n",salution);
    printf("Input something new:\n");
    scanf("%s",salution);                       //数组名代表数组首地址,此处不再需要&运算符
    
    for (int i=0; (c=salution[i]) !='\0'; i++)
        printf("%3c ",salution[i]);             //逐个字符输出,遇结束符'\0’就停止输出
    
    printf("\n\n");
    printf("%s\n",salution);                    //输出整个字符串,遇结束符'\0’就停止输出
    return 0;
}
````

字符数组的输入输出函数：

| 函数      | 作用                                                         | 一般形式(作为语句记得加分号)                   |
| --------- | ------------------------------------------------------------ | ---------------------------------------------- |
| `puts`    | 将一个字符串输出到终端                                       | `puts(str)`                                    |
| `gets`    | 从输入一个终端字符串到字符数组，并得到一个函数值（字符数组首地址） | `gets(str)`                                    |
| `strcat`  | 字符串连接：将 str2 接到 str1中，调用后得到 str1 的地址      | `strcat(str1,str2)`                            |
| `strcpy`  | 字符串复制：将 str2 复制到 str1 中去（str1 足够容纳，且必须写成数组名形式）。 | `strcpy(str1,str2)或strcpy(str1,str2)`         |
| `strncpy` | 字符串复制：将 str2 的前 n 个字符复制到 str1 中去            | `strncpy(str1,str2,3)`或`strncpy(str1,str2,2)` |
| `strcmp`  | 字符串比较：从左到右逐个字符比较（按 ASCII 码大小比较）      | `strcmp(str1,str2)`                            |
| `strlen`  | 测量字符串长度（不含结束符'\0’的实际长度）                   | `strlen(str)`                                  |
| `strlwr`  | 转换为小写                                                   | `strlwr(str)`                                  |
| `strupr`  | 转换为大写                                                   | `strupr(str)`                                  |

【举例】





## 4. 函数

![image-20200912143405365](img/C_functions.png)

注：函数是一段相关代码的抽象，它通过函数名将相关的代码组织在一起，处理输入的数据（参数）后返回特定的输出（返回值）。

###  利用函数实现模块化

函数体现了分治、协作和封装的思想。函数将内部的具体实现封装起来，对外只提供可见的接口，即传入的形参和返回的函数值。

每一个函数（function）实现一个特定的功能，函数名反映函数的功能，是函数整体的抽象。你可以把所有的代码都放在主程序 main 中，但应把每一部分设计成一个独立的函数。把不相关的细节隐藏在函数中，降低了耦合度。此外，这些函数也可以在其它程序中使用。

一个 C 程序可由一个主函数和若干个其他函数构成：由主函数调用其他函数，其他函数也可以互相调用。同一个函数可以被一个或多个函数调用任意多次。允许嵌套调用、递归调用。

说明：

- 一个 C 程序由一个或多个程序模块组成，每个程序模块作为一个源程序文件。

- 一个源程序文件是一个编译单位，由一个或多个函数以及其他有关内容（指令、数据声明与定义等）组成。

- C 程序的执行是从 main 函数开始和结束的

- 所有函数平行（不能嵌套定义）

- 不同系统中，保存在多个源义件中的 C 语言程序的编译与加载机制不同。

  

#### 函数定义

函数定义提供了函数的实际主体，必须先定义后使用。

```c
//	1-有参函数
返回值类型 函数名(形参表)  //函数头
{ 
	函数体
}

//	2-无参函数(void 可省略)
返回值类型 函数名(void) 	 
{ 
	函数体
}


// 3-空函数（程序设计基本模块时使用空函数占位，以便后续扩充功能）
void dummy() {}	
```

- 返回值类型默认`int`型，按函数名调用
- 形参列表：定义函数时给出的输入参数，用于表示函数的输入数据的个数、各数据的类型及名称，便于主调函数向其传递数据。
- 函数之间的通信可以通过<u>参数</u>、<u>函数返回值</u>以及<u>外部变量</u>进行。被调用函数通过 `return` 语句向调用者返回值。



#### 函数声明

函数声明告诉编译器函数的名称、返回类型和参数。这样调用时就知道如何调用函数了。

````c
返回值类型 函数名(形参列表);

float multiple(float x, float y);	//函数声明（一般形式）

float multiple(float, float);	//函数声明（精炼形式）
````

- 函数的定义位于函数调用处之后时需要进行函数声明，把函数名、函数参数个数和参数类型信息通知编译系统，使其能够正确识别函数且检查调用是否合法。函数声明仅比函数首行多一个分号（为了构成语句）。

- 函数原型：函数的首行（函数首部）。使用函数原型做声明，便于对函数调用的合法性进行检查。

-  如果已经在文件开头（所有函数之前）对本文件所调用的函数进行了声明，则在各函数中不必对其所调用的函数再做声明。

- 写在所有函数外面的外部声明在整个文件范围中有效。



#### 函数调用

````c
函数名(实参列表);		//调用函数的语法格式
````

值传递是从实参到形参，单向传递的。C语言中，函数的参数传递就属于「传值（Pass By Value）」调用——把实参值赋给形参。非指针类型的形参，无法在被调函数里改变实参值。但是如果形参是指针类型的，就可以让形参指向实参，此时形参获得了实参的地址，故可以利用指针参数改变实参值。

函数调用的基本原则：实参和形参之间的个数和类型对应一致或兼容；返回值类型的使用应合法。

函数调用本质上是一个表达式。函数只有被调用时才会执行，实参列表是主调函数传递给被调函数的待处理的数据。

函数间可互相调用，可嵌套调用，允许函数的递归调用。但不能调用 main 函数（main 函数被 OS 调用）。

被调函数必须是已定义的函数（库函数或 UDF），调用库函数前，需要先使用 `#include`指令引入相关的头文件。

有限次数的、有终止的递归调用：函数可以直接或间接调用自身。函数递归调用自身时，每次调用都会得到一个与以前的自动变量集合不同的新的自动变量集合。用 if 语句控制，只有在某一条件成立时才继续执行递归调用。

递归并不节省存储器的开销，递归调用过程中必须在某个地方维护一个存储处理值的栈。递归的执行速度并不快，但递归代码比较紧凑，并且比相应的非递归代码更易于编写与理解。



#### 数组做函数参数

数组元素为什么不能做形式参数：形参是在函数被调用时临时分配存储单元的，不可能为一个数组元素单独分配存储单元。数组是一个整体，在内存中占连续的一段存储单元。

数组名做函数实参和形参：形参数组中各元素的值如发生变化会使实参数组元素的值同时发生变化 => 改变实参数组元素的值（如排序）。

多维数组名做函数参数：在定义二维数组时，必须指定列数（即一行中包含几个元素）。形参数组与实参数组类型相同=>他们由具有相同长度的一维数组组成。

````c
//被调函数中形参数组的定义：2 种合法形式（不能省略第2 维及以上高纬的说明），C编译系统不检查第一维的大小。
int array[6][7];
    
int array[][7];

//实参数组
int num[5][7]
    
//形参数组可以不指定大小
float average(float array[]);
````

在对源程序进行编译时，编译系统把形参数组处理为指针变量，该指针变量用来接收从实参数组传过来的地址。C 语言允许用指针变量（如 `float *aaray`）或数组（`float array[]`）作为形参，二者等价。

对数组元素的访问，下标法和指针法也是等价的。

【选择排序】



### 4.2 变量



![image-20200912143510662](img/C_var.png)

注：变量的作用域和生存期和存储属性相关。

#### 外部变量

C 语言程序可以看成由一系列的外部对象构成，这些外部对象可能是变量或函数。

外部变量与函数具有的性质：通过同一个名字对外部变量的所有引用（即使这种引用来自于单独编译的不同函数）实际上都是引用同一个对象（标准中把这一性质称为外部链接）。

关于外部变量的说明：

- 外部变量定义在函数之外，可以在许多函数中使用它。
- 在全局范围内访问（为函数之间的数据交换提供了除函数参数与返回值的额外选项。）

- 任何函数都可以通过通过某种方式进行声明的名字访问一个外部变量。
- 与内部变量相比，外部变量具有更大的作用域和更长的生存期。

如果函数之间需要其享大量的变量，使用外部变量要比使用一个很长的参数表更方便、有效。由于使用外部变量可能对程序结构产生不良的影响，且可能导致程序中各个函数之间具有太多的数据联系，因此要谨慎使用。

自动变量只能在函数内部使用，从其所在的函数被调用时变量开始存在，在函数退出时变量也将消失。

而外部变量是永久存在的，它们的值在一次函数调用到下一次函数调用之间保持不变。因此，如果两个函数必须共享某些数据，而这两个函数互不调用对方，这种情况下最方便的方式便是把这些共享数据定义为外部变量，而不是作为函数参数传递。

例：使用逆波兰表示法（后缀表达式）编写一个具有加（+）、减（-）、乘（）、除（/）四则运算功能的计算器程序。在逆波兰表示法中，不需要圆括号，所有运算符都跟在操作数的后面。



#### 作用域规则

- 如何进行声明才能确保变量在编译时被正确声明？ 

- 如何安排声明的位置才能确保程序在加载时各部分能正确连接？ 

- 如何组织程序中的声明才能确保只有一份副本？ 

- 如何初始化外部变量？

名字的作用域：程序中可以使用该名字的部分。

- 在函数开头声明的自动变量：作用域是声明该变量名的函数。（局部变量）
- 外部变量或函数的作用域：从声明它的地方开始，到其所在的（待编译的）文件的末尾结束。

如果要在外部变量的定义「之前」使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中，则必须在相应的变量声明中强制性地使用「关键字 extern」。 

将外部变量的声明与定义严格区分开来很重要：

- 变量声明：说明变量的属性（主要是变量的类型）。

- 变量定义：说明变量的属性，并为之分配存储单元。

在一个源程序的所有源文件中，一个外部变量只能在某个文件中定义一次，而且外部变量的初始化只能出现在其定义中。

其它文件可以通过 extern 声明来访问它，定义外部变量的源文件中也可以包含对该外部变量的 extern 声明。



#### 静态变量

在正常的对象声明之前加上「关键字 static」 作为前缀，将对象指定为静态存储。作用：将其后声明的对象的作用域限定为编译源文件的剩余部分。通过 static 限定外部对象，以向外部隐藏对象。

外部的 static 声明通常多用于变量，当然，它也可用于声明函数。

函数本质上是全局可访问的，对整个程序的各个部分而言都可见。但是，如果把函数声明为 static 类型，则该函数名除了对该函数声明所在的文件可见外，其它文件都无法访问。

static 也可用于声明内部变量。static 类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。



#### 寄存器变量

register 声明告诉编译器，它所声明的变量在程序中使用频率较高。思想：将register 变量放在机器的寄存器中，这样可以使程序更小、执行速度更快。但编译器可以忽略此选项。register 声明只适用于自动变量以及函数的形式参数。

```c
register int x; 
register char c;
```



#### 程序块结构

C 语言不允许在函数中定义函数，即不允许函数的嵌套定义。

但是，在函数中可以以程序块结构的形式定义变量。变量的声明（包括初始化）除了可以紧跟在函数开始的花括号之后，还可以紧跟在任何其它标识复合语句开始的左花括号之后。

应该避免出现变量名隐藏外部作用域中相同名字的情况， 否则，很可能引起混乱和错误。



#### 初始化

- 未显式初始化时，外部变量和静态变量都将被初始化为 0，而自动变量和寄存器变量的初值则没有定义（即初值为无用的信息）。
- 定义标量变量时，可以在变量名后紧跟一个等号和一个表达式来初始化变量。
- 外部变量与静态变量：初始化表达式必须是「常量表达式」，且只初始化一次（在程序开始执行前进行初始化）。
- 自动变量与寄存器变量：每次进入函数或程序块时都将被初始化。 初始化表达式可以不是常量表达式（表达式中可以包含任意在此表达式之前已经定义的值，包括函数调用。）
- 数组的初始化可以在声明的后面紧跟一个初始化表达式列表，初始化表达式列表用花括号括起来，各初始化表达式之间通过逗号分隔。当省略数组的长度时，编译器将把花括号中初始化表达式的个数作为数组的长度。
- 字符数组的初始化比较特殊：可以用一个字符串来代替用花括号括起来并用逗号分隔的初始化表达式序列。

```c
/数组的初始化/
int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
```



## 5.指针

主要内容：

- 指针就是内存地址，指针变量就是存储内存地址的变量（变量用于存储数据）。

- 定义指针时应该初始化。

- 悬浮指针：定义变量时未初始化的指针，或指向的目标已被销毁的指针。（避免使用）

- C语言提供两种指针运算符：`&`（取址运算符；`*`（间接运算符，用来解引指针，通过指针间接访问内存）。

- 空指针是指其值为 NULL 的指针，空指针不指向任何空间，因此不能用间接运算符（`*`）取值。

- void 指针：指向 void 的指针，类型为 `void *`，表示未确定类型的指针。虽然void 指针指向了一块内存，但只有在转换成具体类型的指针之后，才能获取指针所指向的内存的内容。

- malloc(memory allocation，动态内存分配)：用于申请一块连续的指定大小的内存区域，以 `void *`，返回内存区域地址。

  

| 内容         | 说明                                                         |
| ------------ | :----------------------------------------------------------- |
| 认识指针     | 声明指针，初始化指针，取地址`&`，解引指针`*`，%p，虚拟内存   |
| 动态内存分配 | 内存模型，内存分配和释放，回收内存（内存泄露、迷途指针、垃圾收集、异常处理函数） |
| 指针和函数   | 从函数传递/返回数据：传递数据的技术，用指针返回数据时的常见陷阱；函数指针 |
| 指针和数组   | 指针表示法和数组表示法不能完全互换，但紧密相关               |
| 指针和字符串 | 字符串的基本知识，如何用指针操控字符串，字面量池及其对指针的影响 |
| 指针和结构体 | 结构体的基本知识及其与内存分配和指针的关系，如何在数据结构中使用结构体 |
| 安全使用指针 | 缓冲区溢出                                                   |
| 其他         | 多态，多线程环境中使用指针，restrict 关键字，不透明指针、有界指针 |

#### 指针的使用和内存管理

编程即操控数据，而数据一般在内存中。那如何在内存中存取数据呢？理解 C 程序如何管理内存，就是理解指针的关键。知道 malloc 是从堆上分配内存是一回事，理解内存分配意味着什么则是另一回事。

指针提供了动态操控内存的机制，强化了对数据结构的支持，且实现了访问硬件的功能。指针为动态内存分配提供了重要支持，与数组表示法紧密相关，指向函数的指针也为程序中的流控制提供了更多的选择。

内存管理技术很重要，会牵涉栈（支持函数的内存区域）和堆（支持动态内存分配的内存区域）。

调用函数过程中，系统会创建一个栈帧并将其推到程序栈上。（要求：会使用程序栈和堆，且会在相关上下文背景下使用指针。）理解栈帧和程序栈就可以弄清楚「传值」和「传址」的概念。尽管栈帧和指针没有直接联系，但是理解栈帧有助于理解递归的工作原理。

![image-20200916233551250](img/指针的用途.png)

紧凑的表达式应该用来满足特定的需要。虽然指针清晰灵活，但是使用 C 指针也可能会遇到一些棘手的问题：

![image-20200916233813795](img/使用 C 指针可能会遇到的问题.png)



### 5.1 认识指针

> 指针，指针操作符，如何声明不同类型的指针（比如常量指针、函数指针），如何使用NULL 及相关变体。

#### 5.1.1 指针和内存

指针就是一个存放内存地址的变量，理解指针的关键在于理解 C 程序如何管理内存。归根结底，指针包含的就是内存地址。大部分指针用来操作内存中的数据，因此理解内存的分区和组织方式有助于我们弄清楚指针如何操作内存。C 程序编译后，会以三种形式使用内存：

![image-20200916232330323](img/全局_静态_自动_动态内存.png)

注：动态内存分配在堆上，可根据需要释放，且直到释放才消失。指针引用分配的内存，作用域局限于引用内存的指针。

指针变量包含内存中别的变量、对象或函数的地址。对象就是内存分配函数（比如malloc）分配的内存。指针通常根据所指的数据类型来声明。对象可以是任何 C 数据类型，如整数、字符、字符串或结构体。然而，指针本身并没有包含所引用数据的类型信息，指针只包含地址。

##### 声明指针

```c
int a = 0,b;
int *pi = &a;		//声明指针，同时使用&操作符初始化：将a的地址赋给变量pi，称 pi 为「指向 a 的指针
b = *pi + 1;		//将 pi 所指对象的值取出并加 1，然后再将结果赋值给 b
*pi = 6;			//将 6 赋给 pi 目前所指向的变量 a

printf("Value of pi: %p\n", (void*)pi);		//打印指针的值:%p说明符
```

- 星号将变量声明为指针：在数据类型后面跟星号*，再加上指针变量的名字，星号两边的空白无要求（阅读指针声明：倒着读）

- 尽快初始化指针：只有初始化后指针才会正常工作，因此声明后应初始化指针。指向未初始化的指针可能会产生问题。比如，程序终止，或访问到「垃圾数据：若未初始化则分配的内存中可能包含任何数据」。
- 变量所占内存的实际长度：取决于系统配置。
- 取址符`&`：取地址（返回操作数地址），只能应用于内存中的对象（变量与数组元素）；表达式、常量或 register 类型变量不能用。
- 间接访问运算符 `*`：返回指针变量指向的值（解引指针），即作用于指针时，将访问指针所指向的对象。（取内容）。可以把解引操作符的结果用做左值。
- 一元运算符 `&` 和`*`的优先级比算术运算符的优先级高。

- 如何阅读指针声明：倒过来读，如 `const int *pci;`可以这样读：

  <img src="img/如何阅读指针声明.png" alt="image-20200926132638024" style="zoom:50%;" />

  

- 把整数赋值给指针一般都会导致警告或错误。大部分OS，在程序中使用地址 0 不合法。

- 地址说明符`%p`：打印指针的值，作为地址的说明符。为了在不同的平台上用一致的方式显示指针的值，一种可行的方法是：把指针转换为void 指针。

- 虚拟内存和指针：在虚拟操作系统上显示的指针地址一般不是真实物理内存地址。虚拟操作系统允许程序分布在机器的物理地址空间上。每个程序都假定自己能够访问机器的整个物理内存空间，实际上不是。程序使用的地址是虚拟地址。操作系统会在需要时把虚拟地址映射为物理内存地址。所以【打印出的指针的值，实际上是应用程序的虚拟地址。】

  

| 变量定义        | 类型表示（去掉名称剩余的部分） | 含义(倒着读)                                                 |
| --------------- | ------------------------------ | ------------------------------------------------------------ |
| `int i;`        | `int`                          | 定义整型变量 `i`                                             |
| `int *p;`       | `int *`                        | 定义 `p` 为指向整型数据的指针变量                            |
| `int arr[6];`   | `int [6]`                      | 定义具有 6 个元素的整型数组 `arr`                            |
| `int *p[4];`    | `int *[4]`                     | 定义指针数组 `p`，它由 4 个指向整型数据的指针元素组成        |
| `int （*p)[4];` | `int (*)[4]`                   | `p`为指向包含 4 个元素的一维数组的指针变量                   |
| `int f();`      | `int ()`                       | f 为返回整型函数值的函数                                     |
| `int *p();`     | `int *()`                      | `p` 是返回一个指针的函数，该指针指向整型数据                 |
| `int (*p)();`   | `int (*)();`                   | `p` 是【指向函数的指针】，该函数返回一个整型值               |
| `int **p;`      | `int **`                       | `p` 是一个指针变量，它指向一个指向整型数据的指针变量         |
| `void *p;`      | `void *`                       | `p` 是一个指针变量，基类型为void（空类型），不指向具体的对象 |

指针变量的类型和含义：只有和指针变量的基类型相同的数据的地址才能存放在相应的指针变量内。



##### null 的概念

| 概念                 | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| null 概念            | 指针包含了一个特殊的值，和别的指针不同，它不指向任何内存区域 |
| null 指针常量        | 实际内部表示：null 概念是通过 null 指针常量来支持的一种抽象  |
| NULL 宏（null 指针） | 强制类型转换为 void 指针的整数常量 0：`#define NULL ((void *)0)` |
| ASCII 字符 NUL       | 全 0 的字节                                                  |
| null 字符串          | 空字符串，不包含任何字符                                     |
| null 语句            | 只有一个分号的语句                                           |

- null 指针：null 指针对于很多数据结构的实现非常有用，如链表常用 null 指针表示链尾。
- 如果编译器用一个非零的位串来表示 null，那么编译器就有责任在指针上下文中把 NULL 或 0 当做 null 指针，实际的 null 内部表示由实现定义。使用 NULL 或 0 是在语言层面表示 null 指针的符号。

- null 指针和未初始化的指针不同：未初始化的指针可能包含任何值，而包含 NULL 的指针则不会引用内存中的任何地址。
- 可以给指针赋 0，但是不能赋任何别的整数值（`pi = 0; pi = NULL;`）
- 指针可作为逻辑表达式的唯一操作数，不必显式跟 NULL 比较（`if(pi){...}`）
- 任何时候都不应对 null 指针进行解引（不包含合法地址，执行这样的代码会导致程序终止）
- 使用 NULL 和 0都可以：用 NULL的话，可以提醒自己是在用指针。但 NULL 不应该用在指针之外的上下文中。
- 0 的含义随着上下文的变化而变化：可能是整数 0， null 指针。

| 重载操作符 | 说明                               |
| ---------- | ---------------------------------- |
| 星号       | 可以用来声明指针、解引指针、做乘法 |
| 0          | 整数、null 指针                    |



##### void 指针

```c
void *pv;						//void 指针是通用指针：用来存放任何数据类型的引用
size_t size = sizeof(void*);	//sizeof 操作符可以用在 void 指针上，size_t 是用来表示长度的数据类型
```

- void 指针的性质
  - void 指针具有与 char 指针相同的形式和内存对齐方式
  -  void 指针和别的指针永远不会相等，不过，两个赋值为 NULL 的 void 指针相等

- 任何指针都可以被赋给 void 指针，它可以被转换回原来的指针类型
- void 指针只用做数据指针，不能用做函数指针
- 如何用 void 指针来解决多态的问题？？？
- 用 void 指针时要小心：如果把任意指针转换为 void 指针，那就没有什么能阻止你再把它转换成不同的指针类型了
- sizeof 操作符可以用在 void 指针上，不过无法把这个操作符用在 void 上



##### 全局和静态指针

```c
int *globalptr;					//全局指针

void foo() {
	static int *staticptr;		//静态指针
	...
}

int main() {
	...
}
```

栈帧被推入栈中，堆用来动态分配内存，堆上面的区域用来存放全局 / 静态变量。静态和全局变量一般放在与栈和堆所处的数据段不同的数据段中。

![image-20200926143930601](img/全局和静态指针.png)

#### 5.1.2 指针的长度和类型

##### 指针长度

指针长度取决于使用的机器和编译器。指针长度涉及到用程序的兼容性和可移植性。

- 数据指针的长度通常相同：（大部分现代平台）与指针类型无关， char 指针和结构体指针长度相同。
- 函数指针长度可能与数据指针长度不同，函数指针的长度是可变的。

内存模型：

![image-20200926173414952](img/机器内存模型.png)

注：模型取决于操作系统和编译器，一种操作系统可能支持多种模型，这通常是用编译器选项来控制的。



| 指针相关的4 种预定义类型 | 用途                                                         |
| ------------------------ | ------------------------------------------------------------ |
| size_t                   | 安全地表示长度，必须给这种类型的变量赋正数，推荐格式说明符是 %zu（替代： %u 或 %lu） |
| ptrdiff_t                | 处理指针算术运算（两个指针相减）                             |
| intptr_t 和 uintptr_t    | 存储指针地址                                                 |

- size_t：无符号整数，表示 C 中任何对象所能达到的最大长度。它的目的是：提供一种可移植的方法来声明与系统中可寻址的内存
  区域一致的长度。size_t 用做 sizeof 操作符的返回值类型，同时也是很多函数的参数类型，包括 malloc 和 strlen。在声明诸如字符数或者数组索引这样的长度变量时用 size_t 是好的做法。它经常用于循环计数器、数组索引，有时候还用在指针算术运算上。

  ```c
  // size_t 在标准头文件中的典型定义：size_t 的声明是实现相关的，即实际长度取决于实现
  // size_t 可能的最大值是:SIZE_MAX
  #ifndef __SIZE_T
  #define __SIZE_T
  typedef unsigned int size_t;
  #endif
  ```

- 对指针使用sizeof操作符：sizeof 操作符可以用来判断指针长度。当需要用指针长度时，一定要用 sizeof 操作符。

  ```c
  printf("Size of *char: %lu\n",sizeof(char*));
  ```

- intptr_t 和 uintptr_t 类型用来存放指针地址。它们提供了一种可移植且安全的方法声明指针，而且和系统中使用的指针长度相同，对于把指针转化成整数形式来说很有用。uintptr_t 是 intptr_t 的无符号版本。对于大部分操作，用 intptr_t 比较好。当可移植性和安全性变得重要时，就应该使用这些类型。

  ```c
  int num;
  intptr_t *pi = &num;
  ```



#### 5.1.3 指针操作符

![image-20200926180624476](img/指针操作符.png)

- 数据指针的算术运算：给指针 加/减一个整数，两个指针相减，比较指针。（函数指针则不一定）
  - 给指针加上/减去整数：加或减的数是这个整数和指针数据类型对应字节数的乘积。
  - 指针相减：一个指针减去另一个指针会得到两个地址的差值，可以判断数组中的元素顺序。ptrdiff_t 类型表示两个指针差值的可移植方式。
  - 比较指针：当把指针和数组元素相比时，比较结果可以用来判断数组元素的相对顺序。

<img src="img/数据长度_大部分系统.png" alt="image-20200926181024965" style="zoom:50%;" />

- void指针和加法：试图给 void 指针加 1 可能导致语法错误。

【注】访问超出数组范围的内存很危险，应避免。没有什么能保证被访问的内存是有效变量，存取无效或无用地址的情况很容易发生。



#### 5.1.4 指针的常见用法

##### 多层间接引用

双重指针：把变量声明为指针的指针。（例：用传统的 argv 和 argc 参数来给 main 函数传递程序参数）

用多层间接引用可以为代码的编写和使用提供更多的灵活性。

![image-20200926182219241](img/指针的指针_多层间接引用.png)



```c
//第一个数组:用来存储书名列表的字符串数组
char *titles[] = {"A Tale of Two Cities","Wuthering Heights","Don Quixote","Odyssey","Moby-Dick","Hamlet",
"Gulliver's Travels"};

//两个数组都声明为字符指针的指针：避免对每个书名重复分配内存，确保每个书名的位置唯一
char **bestBooks[3];
char **englishBooks[4];

bestBooks[0] = &titles[0];
bestBooks[1] = &titles[3];
bestBooks[2] = &titles[5];
englishBooks[0] = &titles[0];
englishBooks[1] = &titles[1];
englishBooks[2] = &titles[5];
englishBooks[3] = &titles[6];

printf("%s\n",*englishBooks[1]); // Wuthering Heights
```



#### const 指针常量

常量指针：结合const 关键字与指针，不能通过该指针变量修改指向的内容。

读取完全合法且必要，只是我们不能通过常量指针来修改引用的值。但是常量指针指向的变量自身可以修改其值。

```c
int num = 5;
const int limit = 500;
int *pi; 		
const int *pci; 	// 常量指针（数据类型和 const 关键字的顺序不重要）
pi = &num;
pci = &limit;

*pci = 200;			// 不能通过常量指针修改所指内容（编译错误：Read-only variable is not assignable）
pci = &num;			// 可以改变指针的指向（pci 本身是变量，可以指向其他同类型的变量）
```

指向非常量的常量指针：指针不可变，但是他指向的数据可变。

```c
int num;
int *const cpi = &num;
*cpi = 25;
```

- cpi 必须被初始化为指向非常量变量；

- cpi 不能被修改；

- cpi 指向的数据可以被修改。

  ![image-20200926203710835](img/指向常量的指针.png)

  



提醒：

- 指针使程序不容易理解，且指针使用不当容易指向错误的地方。谨慎地使用指针，便可以利用它写出简单、清晰的程序。
- ANSI C 明确地制定了操纵指针的规则， 且使用类型 void （指向 void的指针）代替 char 作为通用指针的类型。
- 指针只能指向某种特定类型的对象，即每个指针都必须指向某种特定的数据类型。（例外：指向 void 类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身。）



#### 指针

能够存放一个地址的一组存储单元（通常是两个或 4 个字节）。内存中的每一个字节有一个编号（地址），地址指向变量单元。

在程序中一般通过「变量名」找到相应的地址，然后引用变量的值。因此，对变量的访问都是通过地址进行的，即通过地址能找到所需的变量单元。指针就是地址，意思是通过指针能找到以它为地址的内存单元。

「指向」即通过地址体现。通过地址能够找到所需的变量单元，所以称地址指向该变量单元（类似某一房间号指向某个房间）。



####  带类型的地址

为了有效存取一个数据，除了需要位置信息外，还需要该数据的类型信息，只有位置信息无法对该数据进行有效存储。`&a`表示“整型变量 a的地址”。 需要区分：存储单元的地址 vs 存储单元的内容。

| 地址组成 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 位置信息 | 内存编号，即以存储单元编号表示的纯地址（如编号为 2000 的字节） |
| 数据类型 | 地址所指向的数据的类型信息（int、float、char 等）            |



### 5.2 指针变量（地址变量）

（只能）存放地址的变量，指针变量的值即地址（指针）。

| 访问方式 | 说明（假设变量 name）                                        |
| -------- | ------------------------------------------------------------ |
| 直接访问 | 直接按变量名 name 进行的访问（变量名与变量地址一一对应）     |
| 间接访问 | 定义特殊变量（指针变量），用来存放变量 name 的地址，<br />然后通过该特殊变量寻找变量 name 的地址，从而访问变量 name |

#### 指针变量的基类型

用来指定此指针变量可以指向的变量的类型，在定义指针时必须指定基类型（如 int、float、char 等）。必须指定基类型的原因是，不同类型的数据在内存中所占的字节数和存放方式不同。指针变量是基本数据类型派生出来的类型，它不能脱离基本类型而独立存在。一个指针变量只能指向同一类型的变量。如何表示指针类型呢？如下：

> `int`：int 指针或指向 int 的指针，表示指向整型数据的指针类型。



下面是 C 语言定义和引用指针变量的方法，指针变量名 `point_1` 前的`*`表示该变量是指针变量。

```c
/ 1. 定义一个指针变量：基类型为 int 的指针变量可以用来指向整型变量 /
类型名 指针变量名;

/ 2. 举例：int 指针、float 指针、 char 指针 /
int *point_1, point_2;
float *point_3;
char *point_4;

/ 3. 定义指针变量时初始化 /
int *point_1 = &a;

/ 4. 引用变量指针 /
int a, p;
p = &a;				/ 给指针变量赋值（赋值号两侧类型一致）：把 a 的地址赋给指针变量 p /
print("%d",*p);		/ 引用指针变量指向的变量：打印变量 a 的值 /
print("%d",*p);		/ 引用指针变量的值：输出变量 a 的地址，即&a /
```

例1：以两种方式输出变量 `luckyNum` 和 `pi` 的值。

```c
#include <stdio.h>
int main()
{
    int luckyNum = 42, *point_1;
    float pi = 3.14, *point_2;
    point_1 = &luckyNum;
    point_2 = &pi;
    
    
    printf("greatNum = %d, pi =%.2f\n", luckyNum, pi);
    printf("point_1 = %d, point_2 = %.2f\n", point_1, point_2);
    
    return 0;
}
```

例 2：分别使用第3个变量和指针的方法「交换 2 个变量的值」。

```c
#include <stdio.h>

int main()
{
    int p1,p2,a,b;
    /int p;/
    printf("Please enter 2 integer numbers：\n");
    scanf("%d,%d", &a,&b);
    p1 = &a;
    p2 = &b;
    if(a < b)
    {
        /p = p1; p1 = p2; p2 = p;/
        p1 = &b; p2 = &a;
    }
    printf("a = %d, b = %d\n",a,b);
    printf("Max = %d, Min = %d\n",p1,p2);
    return 0;
}
```

例 3：指针变量作为函数参数（将一个变量的地址传送到另一个函数中）。

C 语言中的「参数传递采用传值方式」，因此被调函数不能直接修改主调函数中变量的值。若要修改，可以使主调程序将指向所要交换的变量的指针传递给被调函数。指针参数使得被调用函数能够访问和修改主调函数中对象的值。



### 5.2 动态内存分配

#### 基本步骤

在 C 中动态分配内存的基本步骤：

(1) 用 malloc 类的函数分配内存
(2) 用这些内存支持应用程序
(3) 用 free 函数释放内存

指针的强大很大程度上源于它们能追踪动态分配的内存。通过指针来管理这部分内存是很多操作的基础，包括一些用来处理复杂数据结构的操作。C 程序在运行时环境中执行，这通常是由操作系统提供的环境，支持栈和堆以及其他的程序行为。内存的动态分配：建立程序中的动态数据结构（如链表）。

由于可以先分配内存然后释放，因而应用程序可以更灵活高效地管理内存，无需为适应数据结构可能的最大长度分配内存，只要分配实际需要的内存即可。内存管理对所有程序来说都很重要。有时候内存由运行时系统隐式地管理，比如为自动变量分配内存。

栈（stack）：内存中的动态存储区，用于「非静态的局部变量（包括形参）」的内存分配

堆（heap）：内存中的自由存储区，用于临时存放那些「需要时随时开辟，不需要时随时释放」的数据

对象：从堆上分配出来的内存。这是用分配和释放函数手动实现的，这个过程被称为动态内存管理。

#### 内存泄漏

内存泄露：不再使用已分配的内存却没有将其释放。内存泄漏导致的问题是，无法回收内存并重复利用，堆管理器可用的内存将不断变少。导致内存泄漏的几种情况：

- 丢失内存地址
- 应该调用 free 函数却没有调用（也称为隐式泄漏）：对象在使用的内存其实已经不需要了，应该归还给堆。
- 在释放用 struct 关键字创建的结构体时也可能发生内存泄漏。

| 库函数    | 作用                                             | 函数原型                                     |
| --------- | ------------------------------------------------ | -------------------------------------------- |
| `malloc`  | 从堆上分配内存：一个长度为 size 的连续空间       | `void *malloc(size_t size);`                 |
| `calloc`  | 从堆上分配内存并清零：n 个长度为 size 的连续空间 | `void *calloc(unsigned n，unsigned size);`   |
| `realloc` | 重新分配动态存储区：改变已获得的动态空间的大小   | `void *realloc(void *p，unsigned int size);` |
| `free`    | 将内存块返回堆：释放指针变量 p 所指向的动态空间  | `void free(void *p);`                        |

#### malloc 函数

函数原型：`void* malloc(size_t size);`

典型用法：`int *pi = (int*) malloc(sizeof(int));`

执行 malloc 函数时会进行以下操作：

- 从堆上分配内存
- 内存不会被修改或是清空（新分配的内存包含垃圾数据）
- 返回首字节的地址

当 malloc 无法分配内存时会返回 NULL，在使用它返回的指针之前先检查 NULL 。

```c
int *pi = (int*) malloc(sizeof(int));
if(pi != NULL) {
	// 指针没有问题
} else {
	// 无效的指针
}
```

- 要不要强制类型转换

  引入void 指针赋值给其他任何指针类型，所以就不再需要显式类型转换了。有些开发者认为显式类型转换是不错的做法：可以说明 malloc 函数的用意，代码可以和 C++（或早期的 C 编译器）兼容，后两者需要显式的类型转换。

- 分配内存失败

  若声明了一个指针，但未在使用前为它指向的地址分配内存，则内存通常会包含垃圾，这往往会导致一个无效内存引用的错误。

- 没有给malloc传递正确的参数

  为数据类型分配指定字节数时尽量用 sizeof 操作符。

- 确认所分配的内存数

  没有标准的方法可以知道堆上分配的内存总数。如果我们为一个字符串分配 64 字节，堆管理器会分配额外的内存来管理这个块。所分配内存的总大小，以及堆管理器所用到的内存数，是这两者的和。

- 静态、全局指针和malloc

  初始化静态或全局变量时不能调用函数。

  ```c
  //	编译时错误：Initializer element is not a compile-time constant
  static int *pi = malloc(sizeof(int));	
  
  // 对于静态变量，可以通过在后面用一个单独的语句给变量分配内存来避免这个问题。
  static int *pi;
  pi = malloc(sizeof(int));
  ```

  #### calloc函数

  函数原型：`void *calloc(size_t numElements, size_t elementSize);`

  典型用法：`int *pi = calloc(5,sizeof(int));`

  calloc 会在分配的同时清空内存（将其内容置为二进制 0）。calloc 函数会根据 numElements 和 elementSize 两个参数的乘积来分配内存，并返回一个指向内存的第一个字节的指针。如果不能分配内存，则会返回 NULL。此函数最初用来辅助分配数组内存。如果内存需要清零可以使用 calloc，不过执行 calloc 可能比执行 malloc 慢。

  不用 calloc 的话，用 malloc 函数和 memset 函数可以得到同样的结果：

  ```c
  int *pi = malloc(5 * sizeof(int));
  memset(pi, 0, 5* sizeof(int));
  ```

  #### realloc函数

  函数原型：`void *realloc(void *ptr, size_t size);`

  典型用法：

  realloc 函数会重新分配内存——增加或减少为指针分配的内存（如变长数组）。realloc 函数返回指向内存块的指针。该函数接受两个参数，第一个参数是指向原内存块的指针，第二个是请求的大小。重新分配的块大小和第一个参数引用的块大小不同。返回值是指向重新分配的内存的指针。

  ![image-20200926221400389](img/realloc 函数的行为.png)

```c
char *string1;
char *string2;
string1 = (char*) malloc(16);
strcpy(string1, "0123456789AB");

string2 = realloc(string1, 8);
printf("string1 Value: %p [%s]\n", string1, string1);
printf("string2 Value: %p [%s]\n", string2, string2);
```



【例】建立动态数组，输入 5 个学生的成绩，另外用一个函数检查不及格的并输出。

````c
#include <stdio.h>
#include <stdlib.h>										//动态内存分配要引入该头文件

int main()
{//建立动态数组
    void check(int *);                                  //check 函数声明
    int *p1 = (int*)malloc(5*sizeof(int));              //开辟动态内存区,将地址转换成 int *型以后放入 p1
    printf("Please input the marks of 5 students: ");
    for (int i=0; i<5; i++) scanf("%d",p1+i);           //输入
    check(p1);                                          //调用 check 函数
    free(p1);											//应在同一层管理内存的分配和释放
    return 0;
}

void check(int *p)                                      //check 函数定义
{
    printf("Not Pass:");
    for (int i=0; i<5; i++)
        if (p[i]<60) printf(" %d ",p[i]);
    printf("\n");
}
````

- sizeof 操作符使应用程序更容易移植，还能确定在宿主系统中应该分配的正确的字节数。
- 每次调用 malloc（或类似函数），程序结束时必须有对应的 free 函数调用，以防止内存泄漏。
- 一旦内存被释放，就不应该再访问它了。为了防止意外发生，总是把被释放的指针赋值为 NULL。
- 分配内存时，堆管理器维护的数据结构中会保存额外的信息。





### 5.3 指针和数组

#### 下标法和指针法等价

指针数组常用于存放具有不同长度的字符串。

通过数组下标所能完成的任何操作都可以通过指针来实现。下标和指针运算之间具有密切的对应关系，一个通过数组和下标实现的表达式，可等价地通过指针和偏移量实现。用指针编写的程序比用数组下标编写的程序能使目标程序质量高（占内存少，运行速度快），不过可读性要差一些。

```c
int a[10]，pa;

pa = &a[0];			/将指针 pa 指向数组 a 的第 0 个元素,即 pa 的值为数组元素 a[0]的地址/

pa = a;				/数组名代表首地址，和上一句代码等价/

x = pa;			/把数组元素 a[0]中的内容复制到变量 x 中/

```

数组元素的指针：数组元素的地址。 

`[]`是变址运算符：在计算数组元素 `a[i]`的值时，C 语言是先将其转换为`(a+i)`的形式，然后再进行求值。即按元素首地址加上相对位移量得到要找元素的地址，然后找出该单元中的内容。

- 数组方式：数组元素的地址`&a[i]`或`a+i`，数组元素的内容`a[i]`或`pa[i]`。
- 指针方式：数组元素的地址 `pa+i` ，数组元素的内容`(pa+i)`。
- 数组名和指针的区别：指针是一个变量，语句 `pa=a;` 和 `pa++;`合法；但数组名不是变量，仅代表数组元素的首地址，不能代表整个数组，所以不能对数组名重新赋值或进行自增自减。
- 当把数组名传递给一个函数时，实际传递的是该数组元素的首地址。在被调用函数中，该参数是一个局部变量。因此，数组名参数必须是一个指针，即一个存储地址值的变量。



#### 指针的算术运算

在一定条件下允许对指针进行加、减运算。

C 语言中的指针（地址）算术运算方法一致、有规律，它将指针、数组和地址的算术运算集成在了 一起。

指针与整数之间不能相互转换，但 「0 是惟一的例外」。常量 0 可以赋值给指针，指针也可以和常量 0 进行比较。程序中经常用符号常量 `NULL` 代替常量 0，这样便于更清晰地说明常量 0 是指针的一个特殊值。符号常量 `NULL` 定义在标准头文件`<stddef.h>`中。

【指针算术运算的重要特点】

- 在某些情况下对指针可以进行「比较」运算，比如指针 p 和 q 指向同一个数组的成员时。

- 指针可以「和整数进行相加或相减」运算。`p + n` 表示指针 p 当前指向的对象之后第 n 个对象的地址。指针的减法运算的意义是，（前提）如果 p 和 q 指向相同数组中的元素，且 `p<q`，那么 `q-p+1`就是位于 p 和 q 指向的元索之间的元素的数目。

- 指针的算术运算具有一致性：如果处理的数据类型是比字符型占据更多存储空间的浮点类型，并且 p 是一个指向浮点类型的指针，那么在执行 p++后，p 将指向下一个浮点数的地址。

  

【有效（合法）的指针运算】

- 相同类型指针间的赋值；
- 指针同整数间的加、减；
- 指向相同数组中元素的两个指针相减法或比较；
- 将指针赋值为 0 或指针与 0 之间的比较运算。



#### 通过指针引用数组元素

【快】用指针变量直接指向元组，不必每次重新计算地址。

- 下标法：`a[i]`

- 指针法：`*(p+i)`或 `*(a+i)`，a 是数组名，p是指向数组元素的指针变量，初值`p=a`。

  

【注意】

- 可以通过改变指针变量的值指向不同的元素

- 注意指针变量的当前值，在使用指针变量指向数组元素时，应保证指向数组中的有效元素

  

【利用指针引用数组元素·Tips】将`++`和`--` 运算符用于指针变量，可以使指针变量自动向前或向后移动，指向下一个或上一个元素。

````c
//1.使指针 p 指向下一个元素，再获取值
p++;
*p;

//2.先引用 p 的值，实现取值 *p 运算,然后再使 p 自增 1(👇两条语句等价)
*p++;
*(p++);

//3.先使 p 加 1，再取值
*(++p);

//4.使值加 1 而不是指针加 1
++(*p);

//5.如果 p 当前指向 a 数组中第 i 个元素 a[i]
p=&a[i];	
*(p--);		//先取值，再自减：a[i--];
*(++p);		//先使 p 自增，再取值：a[++i];
*(--p);		//先使 p 自减，再取值：a[--i];
````

````c
/*通过指针引用数组元素*/
#include <stdio.h>
int main()
{
    char a[12],*p=a;
    
    printf("Please Input 11 Characters:\n");
    
    while(p<(a+12))
        scanf("%c",p++);        //通过指针接收终端输入
             
    for(p=a; p<(a+12);p++)	   //重新指向 a[0]，保证指针变量的当前值不出错
        printf("%c",*p);       //用指针指向当前的数组元素
    printf("\n");
    return 0;
}
````



#### 用数组名做函数参数

实参数组名代表该数组的首地址，是一个常量。而形参是用来接收从实参传递过来的数组首地址的，是一个指针变量（只有指针变量才能存放地址）。

当用数组名做形参时，如果形参数组中各元素的值发生变化，实参数组元素的值随之变化。C编译都是将形参数组名作为指针变量处理的。

以变量名和数组名做函数参数的比较：

| 实参类型                     | 变量名   | 数组名               |
| ---------------------------- | -------- | -------------------- |
| 要求形参的类型               | 变量名   | 数组名或指针变量     |
| 传递的信息                   | 变量的值 | 实参数组首元素的地址 |
| 通过函数调用能否改变实参的值 | NO       | 能改变实参数组的值   |

````c
/*用数组名做函数参数*/
#include <stdio.h>
int main()
{
    void invert1(int x[],int n);                 //invert1函数声明
    void invert2(int *x,int n);                 //invert2函数声明
    int *p;
    int arr[12]={1,2,3,4,5,6,7,8,9,10,11,12};   //为了开辟相应的存储空间,定义实参数组必须指定数组大小
    
    printf("Original:\n");
    for (int i=0; i<12; i++)
        printf("%d ",arr[i]);
    printf("\n\n");
    invert1(arr, 12);                         //调用 invert1 函数逆,实参 arr 是数组名
                                        
    
    printf("Inverted:\n");
    for (p=arr; p<(arr+12); p++)
        printf("%d ",*p);
    printf("\n\n");
    
    printf("Inverted again:\n");
    invert2(arr, 12);                      //调用 invert2 函数,实参 arr 是数组名
    for (p=arr; p<(arr+12); p++)
    printf("%d ",*p);
    
    printf("\n\n");
    
   return 0;
}

void invert1(int x[],int n)                       //形参 x 是数组名(实际是一个指针变量,并非真正开辟数组空间)
{
    int temp,i,j,m=(n-1)/2;
    for(i=0;i<=m;i++)
    {
        j=n-1-i;
        temp=x[i];x[i]=x[j];x[j]=temp;
    }
    return;
}

void invert2(int *x,int n)                       //形参 x 是指针变量
{
    int *pt,temp,*i,*j,m=(n-1)/2;
    j=x+n-1;pt=x+m;
    for(i=x;i<=pt;i++,j--)
    {
        temp=*i;*i=*j;*j=temp;
    }
    return;
}
````

如果有一个实参数组，要想在函数中改变此数组中的元素的值，实参与形参的对应关系：

| 实参     | 形参               |
| -------- | ------------------ |
| 数组名   | 数组名（指针变量） |
| 指针变量 | 数组名（指针变量） |

注：如果使用指针变量做实参，必须先使指针变量有确定值，指向一个已定义的对象。（`int arr[12], *p=arr;`）

【选择法排序】用指针方法对 6 个整数从小到大排序。

````c
/*排序:从小到大,选择法,指针实现*/
#include <stdio.h>
int main()
{
    void sort(int x[],int n);    //声明 sort 函数
    int i, a[6],*p=a;            //使指针变量有确定值
    
    printf("Input 6 Integer numbers:\n");
    for (i=0; i<6; i++)
        scanf("%d",p++);
    
    p=a;
    sort(p,6);                //调用 sort 函数
    
    for (p=a,i=0; i<6; i++)
        printf("%d ",*p++);     //先取出指针 p 指向的值,再对 p 自增
    
    printf("\n");
    return 0;
}

void sort(int x[],int n)       //sort 函数:选择法排序(形参使用了数组名,也可以改用指针变量)
{                              //改用指针变量:将 x[]换成 *x,类似 x[j] 的地方换成*(x+j)
    int i,j,k,t;
    for (i=0; i<n-1; i++)       //两层循环
    {
        k=i;
        for (j=i+1; j<n; j++)
            if(x[j]<x[k]) k=j;  //从第一个数开始,如果后面的数比它小,就交换
        if(k!=i)
            {t=x[i];x[i]=x[k];x[k]=t;}
    }
    return;
}
````



#### 通过指针引用多维数组

````c
/*输出二维数组的有关数据*/
#include <stdio.h>
int main()
{
    int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};

    printf("%d, %d\n",a,*a);                 //0行起始地址,0 行 0 列元素地址
    printf("%d, %d\n",a[0],*(a+0));         //0 行 0 列元素地址
    printf("%d, %d\n",&a[0],&a[0][0]);      //0行起始地址,0 行 0 列元素地址
    
    printf("%d, %d\n",a[1],a+1);             //1行起始地址,1 行 0 列元素地址
    printf("%d, %d\n",&a[1][0],*(a+1)+0);     //1 行 0 列元素地址
    
    
    printf("%d, %d\n",a[2],*(a+2));            //2 行 0 列元素地址
    printf("%d, %d\n",&a[2],a+2);              //2行起始地址
    
    printf("%d, %d\n",a[1][0],*(*(a+1)+0));    //1 行 0 列元素的值
    printf("%d, %d\n",*a[2],*(*(a+2)+0));      //1 行 0 列元素的值
    
    return 0;
}

/*
结果：
-272632544, -272632544
-272632544, -272632544
-272632544, -272632544
-272632528, -272632528
-272632528, -272632528
-272632512, -272632512
-272632512, -272632512
5, 5
9, 9
*/
````

二维数组 a有关的指针：记住，行和列序号均从 0 开始。二维数组名是指向行（一维数组），一维数组名是指向列的元素的。

| 表示形式                              | 含义                                                      |
| ------------------------------------- | --------------------------------------------------------- |
| `a`                                   | 二维数组名，是二维数组的首行起始地址，指向一维数组 `a[0]` |
| `a+1, &a[1]`                          | a[0]是一维数组名，1行起始地址                             |
| `a[0]`, `*(a+0)`, `*a`                | 0 行 0 列元素地址                                         |
| `a[1]`, `*(a+1)`                      | `a[1][0]`的地址                                           |
| `a[1]+2`, `*(a+1)+2`, `&a[1][2]`      | `a[1][2]`的地址                                           |
| `*(a[1]+2)`, `*(*(a+1)+2)`, `a[1][2]` | `a[1][2]`的值                                             |

- 在指向行的指针前面加上一个`*`， 就转换为指向列的指针。
- 在指向列的指针前面加上一个`&`，就转换为指向行的指针。
- `a`和 `a[0]`纯地址相同，但基类型不同。
- `a+1`和 `a[0]+1`不同：对不同的指针进行加 1的运算，结果不同。`a+1`表示移动一行，`a[0]+1 `表示第 0 行移动一列。



指向多维数组元素的指针变量

### 5.4 指针和字符串

字符串常量是一个字符数组，在字符串的内部表示中，字符数组以空字符`'\0'`结尾，常用作函数参数。``printf` 接受的是一个指向字符数组第一个字符的指针，即可通过一个指向其第一个元素的指针访问字符串常量。

````c
/*字符串复制函数: 数组 or 指针变量实现*/
#include <stdio.h>
int main()
{
    void strcpy_by_aaray(char from[],char to[]);    //函数声明：数组实现
    char a[] = "Hello,guys. Welcome!", b[32];
    
    strcpy_by_aaray(a,b);                          //函数调用：用字符数组名做函数实参
    printf("String a is:%s\n", a);
    printf("String b is:%s\n", b);
    return 0;
}

void strcpy_by_aaray(char from[],char to[])
{//通过地址访问字符串（数组实现）
    int i=0;
    while ((to[i] = from[i])) 
        i++;			
    to[i] = '\0';
}

void strcpy_by_pointer(char *from,char *to)
{//通过「指针变量」访问字符串:主调函数里将相应的函数声明和调用替换成此函数即可。
    
    while ((*to++ = *from++));       	//判断-赋值-自增(使指针 to 和 from 同步移动)
    *to = '\0';							//最后加一个字符串结束标志
}

/*复制字符串:通过指针变量访问字符串(减少变量个数)*/
#include <stdio.h>
int main()
{
    char *str = "Hello,guys. Welcome!", strcopy[32], *p = strcopy; //str是一个指针
    printf("String str is:  %s\n",str);
    
    while (*str) *p++ = *str++;  		//先赋值再自增(使指针 p 和 str 同步移动)
    *p='\0';                            //最后加一个字符串结束标志
    
    printf("Copy of str is: %s\n",strcopy);   
    return 0;
} 
````

说明：while 循环都可以用 for 循环替换。

```c
//1. 下面两条语句等价 
while ((to[i] = from[i])) i++;
while ((to[i] = from[i])!='\0') i++;

//2. 下面语句等价
while ((*to++ = *from++)); 

while((*to = *from)!='\0') 
	{from++;to++;}
```

字符串比较函数 `strcmp(s, t)`：为了避免和系统提供的冲突，改为了 str_cmp。

```c
#include <stdio.h>
int main()
{
    int str_cmp(char str1[], char str2[]);    	//函数声明
    char a[] = "Hello", b[]="Hello,world!";
                          
    printf("%d\n",str_cmp(a,b));				//函数调用：用字符数组名做函数实参
    return 0;
}

int str_cmp(char str1[], char str2[])
{//实现 1
    int i;
  	for (i = 0; str1[i] == str2[i]; i++)
    if (str1[i] == '\0') 
        return 0;               //相等返回 0
    return str1[i] - str2[i] < 0 ? -1 : 1;       //小于返回-1,大于返回1
}


int str_cmp(char str1[], char str2[])
{//实现 2：为了不用更改主函数对被调函数的声明和调用，与实现 1 一样，使用数组名做形参,且函数同名。
    char *s = str1, *t = str2;    
    
    while(*s == *t)
        { s++;t++; }
    if (*s == '\0')
        return 0;
    return s - t < 0 ? -1 : 1;
}
```

进栈和出栈的标准用法：

```c
p++ = val; /* 将 val 压入栈 */ 
val = --p; /* 将栈顶元素弹出到 val 中: 在读取指针 p 指向的字符之前先对 p 执行自减运算*/
```



### 5.5 函数和指针

指向函数的指针：函数经过编译后，在内存中会占有一块内存空间，该空间有一个首地址，可以使用一个指针变量来存储这个地址。其实，函数名就是指向函数的指针，代表函数的起始地址。

````c
类型名(*指针变量名)(函数参数列表);	//形参列表两侧的这对圆括号是函数的特征，*号指明了是指针变量	
````

调用函数时，从函数名得到函数的起始地址，并执行函数代码。

````c
int(*p)(int, int);				//指针变量 p 可以指向函数返回值为整型且有两个整型参数的函数

//	下面两种赋值语句等价
p=max;							//给函数指针变量赋值，max 是函数名
c=(*p)(a,b);					//通过指针实现函数调用：调用由 p 指向的函数，实参为 a、b。得到的值赋给 c。

c=max(a,b);						//一般的函数调用
````

- `(*p)`两侧的括号不能省，表示p先与*结合，是指针变量，然后再与后面的（）结合，是函数。即：该指针变量不是指向一般的变量，而是指向函数。

- 在一个程序中，一个指针变量可以先后指向同类型的不同函数。

- 在给函数指针变量赋值时，只需给出函数名（不涉及实参与形参的结合问题）。

- 用函数指针变量调用函数时，只要使用`(*p)`代替函数名即可（p 为指针变量名）,在`(*p)`之后的括号中根据需要写上实参。

- 对指向函数的指针变量不能进行算术运算（只能指向函数的入口处）。

- 用函数名调用函数，只能调用所指定的一个函数。而通过指针变量调用函数，可以根据不同情况先后调用不同的参数。

  

【例】输入两个整数，然后让用户选择 1 或 2：选 1 时调用 max 函数，输出二者中的大数；选 2 时调用 min 函数，输出二者中较小的数。

````c
#include <stdio.h>
int main()
{
    int max(int,int);
    int min(int,int);
    
    int (*p)(int,int);      //定义指向函数的指针变量
    int a,b,c,n;
    
    printf("Please enter a and b: ");
    scanf("%d,%d",&a,&b);
    printf("Please choose 1 for max or 2 for min : ");
    scanf("%d",&n);
    
    if (n==1) p=max;
    if (n==2) p=min;
    
    c=(*p)(a,b);
    
    printf("a=%d,b=%d\n",a,b);
    
    if(n==1) printf("max=%d\n",c);
    else printf("min=%d\n",c);
    return 0; 
}


int max(int x, int y)
{
    int z;
    return z = x >= y ? x : y;
}

int min(int x, int y)
{
    int z;
    return z = x <= y ? x : y;
}
````



### 5.5 用指向函数的指针做函数参数

把函数的入口地址作为参数传递到其他函数。

### 5.6 返回指针值的函数

````c
//函数也可以返回指针型的数据，即地址
类型名 *函数名(参数表列);
int *a(int x, int y);
````

### 5.7 指针数组和多重指针

指针数组：数组的元素为指针类型的数据，即指针数组中的每个元素都存放一个地址，相当于一个指针变量。

指针数组适合用来指向若干个字符串（字符串本身也是一个字符数组），比使用二维数组处理字符串灵活。

````c
//定义一维指针数组
类型名 *数组名[数组长度];
int *p[4];
````









## 6. struct

> 结构（struct）：自定义数据类型，可以用来组织一组不同类型的相关数据。结构成员类型可以是基本数据类型、数组、指针和其他结构。



结构（struct）是一种由不同类型数据组成的组合型数据结构，即将一组类型不同的、用来描述同一事物的变量相组合的一种数据组织方式。通过结构类型把基本数据类型和派生数据类型相组合，将这组相关的变量看作一个单元，有助于我们在大型的程序中组织复杂的数据。结构可以拷贝、赋值、 传递给函数，函数也可以返回结构类型的返回值。

主要内容：

- 如何声明结构（struct）类型
- 如何定义、初始化及引用结构变量
- 如何定义和使用结构数组
- 如何定义和使用结构指针
- 使用结构类型和指针实现链表



#### 结构类型声明和结构变量

struct 声明定义了一种组合的数据类型，和基本数据类型用途相同。声明结构类型之后，可以用其定义结构类型的变量，即结构变量。结构类型声明不会引起系统为其分配空间，只有在定义了该结构类型的变量时才会为该结构类型变量分配内存空间。

结构变量的内存空间大小为所有成员空间大小的总和。考虑内存对齐时，结构类型的内存空间大小y应为：结构成员中所占内存空间字节数最大者的整数倍。

````c
typedef struct
{
    int month;						//月（结构中定义的变量称为结构成员）
    int day;						//日
    int year;						//年
}Date;//结构类型声明

typedef struct 
{
    char name[32];			
    int employeeID;			
    int groupID;			
    double salary;			
    Date birthday;						//生日（结构类型声明可嵌套，即一个结构体可以作为另一个结构体的成员）
}Employee;

Employee employee1,employee2;			//结构变量定义

employee1.name = "Zhang San";			//访问结构成员（点运算符）
employee1.Date.day = 23;				//只能操作最低一级的结构成员
employee2 = employee1;					//同类型的结构变量可以互相赋值

scanf("%d",&employee1.employeeID);		//引用结构变量成员的地址
printf("%o",&employee1);				//引用结构变量的地址（用作函数参数，传递结构体变量的地址）
````

注：使用类型定义 typedef 给相应的结构类型定义了同义词。



#### 结构数组

结构数组就是使用结构类型去定义一个数组，该数组中的元素为结构类型（与基本类型数组的差异）。只能对结构数组元素的单个成员进行输入或输出操作，而不能将结构数组元素作为一个整体操作。

````c
typedef struct {
    char name[32];
    int  count;
    char gender[32];
    char slogn[64];
}Candidate;//定义结构类型Candidate

Candidate candidates[2] = {
    {"Waner Lee",0,"Female","Justice & Peace"},
    {"Er Wang",0,"Male","Order & Economy"}
};//结构数组
````

【举例：奖学金问题】

````c
#include <stdio.h>

typedef struct student {
    char name[32];
    int averScore;
    int classScore;
    char isLeader;
    char fromWest;
    int articlesCount;
}Student;//结构类型声明

int main(void) {
    Student stu[100];       //结构数组
    int n;
    
    scanf("%d",&n);
    int totalBonus = 0;
    int maxBouns = 0, index = 0;
    
    for (int i = 0; i < n; i++) {
        int bonus = 0;
        scanf("%s %d %d %c %c %d",stu[i].name,&stu[i].averScore,&stu[i].classScore,&stu[i].isLeader,&stu[i].fromWest,&stu[i].articlesCount);
        if (stu[i].averScore > 80 && stu[i].articlesCount >= 1) bonus += 8000;
        if (stu[i].averScore > 85 && stu[i].classScore >= 80) bonus += 4000;
        if (stu[i].averScore > 90) bonus += 2000;
        if (stu[i].averScore > 85 && stu[i].fromWest =='Y') bonus += 1000;
        if (stu[i].averScore > 80 && stu[i].isLeader =='Y') bonus += 850;
        totalBonus += bonus;
        if (bonus > maxBouns) {
            maxBouns = bonus;
            index = i;
        }
    }
    
    printf("%s\n%d\n%d\n",stu[index].name,maxBouns,totalBonus);

    return 0;
}
````



####  结构指针

````c
#include <stdio.h>


typedef struct {
        int x;
        int y;
        int z;
}Point;

int main() {
    
    Point point_1 = {0,0,0};   //定义结构变量时初始化

    Point *p; 					//结构指针：指向结构变量的指针,即结构变量的起始地址
    p = &point_1;

    point_1.x = 3;
    (*p).y = 2;
    p->z = 1;               	//指向运算符（->）：访问结构类型变量的成员
    
    printf("%d %d %d\n",p->x,p->y,p->z);
    
    return 0;
}//输出: 3 2 1
````

当指针 `p` 指向一个结构变量`point_1`时，以下用法等价：

- `point_1.成员名`：`point_1.x`

- `(*p).成员名`：`(*p).x`

- `p->成员名`：`p->x`

  

### 结构与函数

结构的合法操作（结构之间不可以进行比较）：

- 作为一个整体复制和赋值（包括向函数传递参数、从函数返回值）
- 通过`&`运算符取地址
- 访问成员
- 可以用一个常量成员值列表初始化结构，也可以通过赋值进行初始化。

至少可以通过 3 种可能的方法传递结构：

- 分别传递各个结构成员
- 传递整个结构
- 传递指向结构的指针



## 7. 类型定义（typedef）



> 类型定义（typedef）：利用 `typedef`  建立新的数据类型名，实质是为特定类型指定了一个同义字。



`typedef` 在编译阶段处理，采用如同定义变量的方法生成一个类型名后再用它去定义变量。



使用 typedef 的原因：

- 用 `typedef` 声明数组、指针、结构、联合、枚举等类型时，方便编程

- 当不同源文件中要用到同一类型数据，尤其是数组、指针、结构、联合、枚举等类型数据时，可以把所有的 `typedef` 名称声明单独放在一个头文件中，之后在需要使用的文件中使用`#include` 指令导入该头文件即可。

- 扩展了程序的通用性和可移植性

  

声明一个新的类型名的步骤如下：

- 按定义变量的方法写出定义体
- 将变量名换成新类型名(首字母大写)
- 在最前面加 typedef
- 用新类型去定义变量

```c
// 用一个新的类型名代替：原有的类型名
typedef float Real;
Real a,b;

// 命名一个新的类型名代替：结构类型	
typedef struct {
    int month;
    int day;
    int year;
}Date;		

Date birthday;
Date *currentDate；
 
// 命名一个新的类型名代替：数组类型
typedef int Num[20];
Num a,b,c;

// 命名一个新的类型名代替：指针类型
typedef char* String;
String p,s[10];					//p 为字符指针变量，s 为字符指针数组

//命名一个新的类型代替：指向函数的指针类型
typedef int(*FuncPointer)();	
FuncPointer ptr1,ptr2;
```



## 8. 对文件的输入输出



## 说明

Stanford CS Education Library This is document #101, Essential C, in the Stanford CS Education Library. This and other educational materials are available for free at http://cslibrary.stanford.edu/. This article is free to be used, reproduced, excerpted,

retransmitted, or sold so long as this notice is clearly reproduced at its beginning.



## 参考

《The C Programming Language》

《C程序设计·第五版》（谭浩强）

《Essential C》

《深入理解 C 指针》



## 附录

C语言中的关键字

| auto       | break    | case     | char   | const   | continue |
| ---------- | -------- | -------- | ------ | ------- | -------- |
| default    | do       | double   | else   | enum    | extern   |
| float      | for      | goto     | if     | inline  | int      |
| long       | register | restrict | return | short   | signed   |
| sizeof     | static   | struct   | switch | typedef | union    |
| unsigned   | void     | volatile | while  | _bool   | _Complex |
| _Imaginary |          |          |        |         |          |

